-- =============================================================================
-- GEO_PROJECT — MONITORING (CLEAN + DEBUG FRIENDLY)
-- Notes:
--  - LOGIC IS NOT CHANGED: pipe_status via LISTAGG/UNION, copy_history via ACCOUNT_USAGE
--  - Views are snapshots-based; run CALLs once to populate snapshot tables
-- =============================================================================

USE DATABASE GEO_PROJECT;
CREATE SCHEMA IF NOT EXISTS MONITORING;
USE SCHEMA MONITORING;

-- =============================================================================
-- STEP 0) (optional) Housekeeping
-- =============================================================================
-- DROP SCHEMA IF EXISTS MONITORING CASCADE;
-- CREATE SCHEMA MONITORING;
-- USE SCHEMA MONITORING;

-- =============================================================================
-- STEP 1) PIPE REGISTRY (idempotent)
-- =============================================================================
CREATE OR REPLACE TABLE MONITORING.PIPE_REGISTRY (
  PIPE_NAME     STRING,   -- e.g. 'TASKS.P_OSM_CHARGING'
  TARGET_TABLE  STRING,   -- e.g. 'GEO_PROJECT.BRONZE.LND_OSM_CHARGING'
  INTEGRATION   STRING,   -- e.g. 'GEO_AZ_NOTIF_OSM'
  STAGE_NAME    STRING,   -- e.g. 'TASKS.OSM_RAW_STAGE'
  IS_ENABLED    BOOLEAN DEFAULT TRUE,
  CREATED_AT    TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP(),
  UPDATED_AT    TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP()
);

MERGE INTO MONITORING.PIPE_REGISTRY t
USING (
  SELECT * FROM VALUES
    -- OSM (8)
    ('TASKS.P_OSM_ADMIN',              'GEO_PROJECT.BRONZE.LND_OSM_ADMIN',              'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),
    ('TASKS.P_OSM_ROADS',              'GEO_PROJECT.BRONZE.LND_OSM_ROADS',              'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),
    ('TASKS.P_OSM_CHARGING',           'GEO_PROJECT.BRONZE.LND_OSM_CHARGING',           'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),
    ('TASKS.P_OSM_POI_POINTS',         'GEO_PROJECT.BRONZE.LND_OSM_POI_POINTS',         'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),
    ('TASKS.P_OSM_POI_POLYGONS',       'GEO_PROJECT.BRONZE.LND_OSM_POI_POLYGONS',       'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),
    ('TASKS.P_OSM_PT_POINTS',          'GEO_PROJECT.BRONZE.LND_OSM_PT_POINTS',          'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),
    ('TASKS.P_OSM_PT_LINES',           'GEO_PROJECT.BRONZE.LND_OSM_PT_LINES',           'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),
    ('TASKS.P_OSM_BUILDINGS_ACTIVITY', 'GEO_PROJECT.BRONZE.LND_OSM_BUILDINGS_ACTIVITY', 'GEO_AZ_NOTIF_OSM',      'TASKS.OSM_RAW_STAGE',      TRUE),

    -- GISCO (1)
    ('TASKS.P_GISCO_NUTS',             'GEO_PROJECT.BRONZE.LND_GISCO_NUTS',             'GEO_AZ_NOTIF_GISCO',    'TASKS.GISCO_RAW_STAGE',    TRUE),

    -- EUROSTAT (3)
    ('TASKS.P_EUROSTAT_LAU_DEGURBA',              'GEO_PROJECT.BRONZE.LND_EUROSTAT_LAU_DEGURBA',             'GEO_AZ_NOTIF_EUROSTAT', 'TASKS.EUROSTAT_RAW_STAGE', TRUE),
    ('TASKS.P_EUROSTAT_CENSUS_GRID_2021_EUROPE',  'GEO_PROJECT.BRONZE.LND_EUROSTAT_CENSUS_GRID_2021_EUROPE', 'GEO_AZ_NOTIF_EUROSTAT', 'TASKS.EUROSTAT_RAW_STAGE', TRUE),
    ('TASKS.P_EUROSTAT_TRAN_R_ELVEHST',           'GEO_PROJECT.BRONZE.LND_EUROSTAT_TRAN_R_ELVEHST',          'GEO_AZ_NOTIF_EUROSTAT', 'TASKS.EUROSTAT_RAW_STAGE', TRUE)
) s(PIPE_NAME, TARGET_TABLE, INTEGRATION, STAGE_NAME, IS_ENABLED)
ON t.PIPE_NAME = s.PIPE_NAME
WHEN MATCHED THEN UPDATE SET
  TARGET_TABLE = s.TARGET_TABLE,
  INTEGRATION  = s.INTEGRATION,
  STAGE_NAME   = s.STAGE_NAME,
  IS_ENABLED   = s.IS_ENABLED,
  UPDATED_AT   = CURRENT_TIMESTAMP()
WHEN NOT MATCHED THEN INSERT (PIPE_NAME, TARGET_TABLE, INTEGRATION, STAGE_NAME, IS_ENABLED)
VALUES (s.PIPE_NAME, s.TARGET_TABLE, s.INTEGRATION, s.STAGE_NAME, s.IS_ENABLED);

-- === DEBUG NOW (after STEP 1) ===
-- Expect 12 rows
-- SELECT * FROM MONITORING.PIPE_REGISTRY ORDER BY PIPE_NAME;


-- =============================================================================
-- STEP 2) SNAPSHOT TABLES
-- =============================================================================
CREATE OR REPLACE TABLE MONITORING.PIPE_STATUS_SNAPSHOTS (
  SNAPSHOT_TS TIMESTAMP_NTZ,
  PIPE_NAME   STRING,
  STATUS      VARIANT
);

CREATE OR REPLACE TABLE MONITORING.COPY_HISTORY_SNAPSHOTS (
  SNAPSHOT_TS          TIMESTAMP_NTZ,
  PIPE_NAME            STRING,
  TARGET_TABLE         STRING,
  FILE_NAME            STRING,
  STAGE_LOCATION       STRING,
  STATUS               STRING,
  FIRST_ERROR_MESSAGE  STRING,
  ROW_COUNT            NUMBER,
  ROW_PARSED           NUMBER,
  FILE_SIZE            NUMBER,
  LAST_LOAD_TIME       TIMESTAMP_NTZ,
  PIPE_RECEIVED_TIME   TIMESTAMP_NTZ,
  BYTES_BILLED         NUMBER
);

-- === DEBUG NOW (after STEP 2) ===
-- SHOW TABLES LIKE '%SNAPSHOTS%' IN SCHEMA MONITORING;


-- =============================================================================
-- STEP 3) PROC: SNAP PIPE STATUS
-- =============================================================================
CREATE OR REPLACE PROCEDURE MONITORING.SNAP_PIPE_STATUS()
RETURNS VARIANT
LANGUAGE SQL
EXECUTE AS OWNER
AS
$$
DECLARE
  v_union STRING;
  v_sql   STRING;
  v_cnt   NUMBER;
BEGIN
  SELECT COUNT(*)
    INTO :v_cnt
  FROM MONITORING.PIPE_REGISTRY
  WHERE IS_ENABLED;

  IF (v_cnt = 0) THEN
    RETURN OBJECT_CONSTRUCT('status','NOOP','snapped_pipes',0,'reason','PIPE_REGISTRY empty or disabled');
  END IF;

  SELECT LISTAGG(
           'SELECT CURRENT_TIMESTAMP() AS SNAPSHOT_TS, ' ||
           '''' || REPLACE(PIPE_NAME, '''', '''''') || ''' AS PIPE_NAME, ' ||
           'SYSTEM$PIPE_STATUS(''' || REPLACE(PIPE_NAME, '''', '''''') || ''')::VARIANT AS STATUS',
           ' UNION ALL '
         )
    INTO :v_union
  FROM MONITORING.PIPE_REGISTRY
  WHERE IS_ENABLED;

  v_sql := 'INSERT INTO MONITORING.PIPE_STATUS_SNAPSHOTS (SNAPSHOT_TS, PIPE_NAME, STATUS) ' || v_union;

  EXECUTE IMMEDIATE v_sql;

  RETURN OBJECT_CONSTRUCT('status','OK','snapped_pipes',v_cnt);
END;
$$;

-- === DEBUG NOW (after STEP 3) ===
-- CALL MONITORING.SNAP_PIPE_STATUS();
-- SELECT COUNT(*) FROM MONITORING.PIPE_STATUS_SNAPSHOTS;


-- =============================================================================
-- STEP 4) PROC: SNAP COPY HISTORY (ACCOUNT_USAGE)
-- =============================================================================
CREATE OR REPLACE PROCEDURE MONITORING.SNAP_COPY_HISTORY(HOURS_BACK NUMBER)
RETURNS VARIANT
LANGUAGE SQL
EXECUTE AS OWNER
AS
$$
DECLARE
  v_rows NUMBER DEFAULT 0;
BEGIN
  INSERT INTO MONITORING.COPY_HISTORY_SNAPSHOTS
  (
    SNAPSHOT_TS, PIPE_NAME, TARGET_TABLE, FILE_NAME, STAGE_LOCATION, STATUS, FIRST_ERROR_MESSAGE,
    ROW_COUNT, ROW_PARSED, FILE_SIZE, LAST_LOAD_TIME, PIPE_RECEIVED_TIME, BYTES_BILLED
  )
  SELECT
    CURRENT_TIMESTAMP() AS SNAPSHOT_TS,
    r.PIPE_NAME         AS PIPE_NAME,
    r.TARGET_TABLE      AS TARGET_TABLE,
    c.FILE_NAME,
    c.STAGE_LOCATION,
    c.STATUS,
    c.FIRST_ERROR_MESSAGE,
    c.ROW_COUNT,
    c.ROW_PARSED,
    c.FILE_SIZE,
    c.LAST_LOAD_TIME,
    c.PIPE_RECEIVED_TIME,
    c.BYTES_BILLED
  FROM MONITORING.PIPE_REGISTRY r
  JOIN SNOWFLAKE.ACCOUNT_USAGE.COPY_HISTORY c
    ON (c.TABLE_CATALOG_NAME || '.' || c.TABLE_SCHEMA_NAME || '.' || c.TABLE_NAME) = r.TARGET_TABLE
   AND (c.PIPE_SCHEMA_NAME  || '.' || c.PIPE_NAME) = r.PIPE_NAME
  WHERE r.IS_ENABLED
    AND c.LAST_LOAD_TIME >= DATEADD('HOUR', -:HOURS_BACK, CURRENT_TIMESTAMP());

  v_rows := (SELECT COUNT(*)
             FROM MONITORING.COPY_HISTORY_SNAPSHOTS
             WHERE SNAPSHOT_TS >= DATEADD('MINUTE', -5, CURRENT_TIMESTAMP()));

  RETURN OBJECT_CONSTRUCT('status','OK','hours_back',HOURS_BACK,'inserted_recent_rows',v_rows);
END;
$$;

-- === DEBUG NOW (after STEP 4) ===
-- CALL MONITORING.SNAP_COPY_HISTORY(24);
-- SELECT COUNT(*) FROM MONITORING.COPY_HISTORY_SNAPSHOTS;


-- =============================================================================
-- STEP 5) VIEWS (snapshots-based)
-- =============================================================================

-- 5.1 Latest pipe status
CREATE OR REPLACE VIEW MONITORING.V_PIPE_STATUS_LATEST AS
SELECT
  s.SNAPSHOT_TS,
  s.PIPE_NAME,
  s.STATUS,
  s.STATUS:executionState::STRING AS EXEC_STATE,
  TRY_TO_NUMBER(s.STATUS:pendingFileCount::STRING) AS PENDING_FILE_COUNT,
  TRY_TO_NUMBER(s.STATUS:numOutstandingMessagesOnChannel::STRING) AS OUTSTANDING_MSGS,
  s.STATUS:lastPulledFromChannelTimestamp::TIMESTAMP_NTZ AS LAST_PULL_TS,
  s.STATUS:lastIngestedTimestamp::TIMESTAMP_NTZ          AS LAST_INGESTED_TS,
  s.STATUS:lastIngestedFilePath::STRING                  AS LAST_INGESTED_FILE,
  s.STATUS:lastError::STRING                             AS LAST_ERROR
FROM MONITORING.PIPE_STATUS_SNAPSHOTS s
QUALIFY ROW_NUMBER() OVER (PARTITION BY s.PIPE_NAME ORDER BY s.SNAPSHOT_TS DESC) = 1;

-- 5.2 Latest pipe status enriched with registry fields (NEW)
CREATE OR REPLACE VIEW MONITORING.V_PIPE_STATUS_LATEST_ENRICHED AS
SELECT
  r.PIPE_NAME,
  r.TARGET_TABLE,
  r.INTEGRATION,
  r.STAGE_NAME,
  r.IS_ENABLED,
  v.SNAPSHOT_TS,
  v.EXEC_STATE,
  v.PENDING_FILE_COUNT,
  v.OUTSTANDING_MSGS,
  v.LAST_PULL_TS,
  v.LAST_INGESTED_TS,
  v.LAST_INGESTED_FILE,
  v.LAST_ERROR
FROM MONITORING.PIPE_REGISTRY r
LEFT JOIN MONITORING.V_PIPE_STATUS_LATEST v
  ON v.PIPE_NAME = r.PIPE_NAME;

-- 5.3 Copy errors
CREATE OR REPLACE VIEW MONITORING.V_COPY_ERRORS AS
SELECT
  PIPE_NAME,
  TARGET_TABLE,
  FILE_NAME,
  STATUS,
  FIRST_ERROR_MESSAGE,
  LAST_LOAD_TIME,
  PIPE_RECEIVED_TIME,
  SNAPSHOT_TS
FROM MONITORING.COPY_HISTORY_SNAPSHOTS
WHERE (STATUS ILIKE 'LOAD FAILED%' OR STATUS ILIKE 'FAILED%' OR STATUS ILIKE 'LOAD_FAILED%')
   OR FIRST_ERROR_MESSAGE IS NOT NULL
QUALIFY ROW_NUMBER() OVER (PARTITION BY PIPE_NAME, TARGET_TABLE, FILE_NAME ORDER BY LAST_LOAD_TIME DESC) = 1;

-- 5.4 Freshness (minutes since last success)
CREATE OR REPLACE VIEW MONITORING.V_FRESHNESS AS
SELECT
  PIPE_NAME,
  TARGET_TABLE,
  MAX(CASE WHEN UPPER(STATUS) LIKE 'LOADED%' THEN LAST_LOAD_TIME END) AS LAST_SUCCESS_LOAD_TIME,
  DATEDIFF(
    'MINUTE',
    MAX(CASE WHEN UPPER(STATUS) LIKE 'LOADED%' THEN LAST_LOAD_TIME END),
    CURRENT_TIMESTAMP()
  ) AS MINUTES_SINCE_SUCCESS
FROM MONITORING.COPY_HISTORY_SNAPSHOTS
GROUP BY PIPE_NAME, TARGET_TABLE;

-- 5.5 Throughput 24H
CREATE OR REPLACE VIEW MONITORING.V_THROUGHPUT_24H AS
SELECT
  PIPE_NAME,
  TARGET_TABLE,
  DATE_TRUNC('HOUR', LAST_LOAD_TIME) AS HOUR_TS,
  SUM(COALESCE(ROW_COUNT,0))         AS ROWS_LOADED,
  SUM(COALESCE(FILE_SIZE,0))         AS BYTES_LOADED
FROM MONITORING.COPY_HISTORY_SNAPSHOTS
WHERE LAST_LOAD_TIME >= DATEADD('HOUR', -24, CURRENT_TIMESTAMP())
  AND UPPER(STATUS) LIKE 'LOADED%'
GROUP BY PIPE_NAME, TARGET_TABLE, DATE_TRUNC('HOUR', LAST_LOAD_TIME);

-- 5.6 Last success file per pipe 
CREATE OR REPLACE VIEW MONITORING.V_LAST_SUCCESS_FILE AS
SELECT
  PIPE_NAME,
  TARGET_TABLE,
  FILE_NAME,
  LAST_LOAD_TIME,
  ROW_COUNT,
  FILE_SIZE
FROM MONITORING.COPY_HISTORY_SNAPSHOTS
WHERE UPPER(STATUS) LIKE 'LOADED%'
QUALIFY ROW_NUMBER() OVER (PARTITION BY PIPE_NAME, TARGET_TABLE ORDER BY LAST_LOAD_TIME DESC) = 1;

-- 5.7 Health summary 
CREATE OR REPLACE VIEW MONITORING.V_PIPE_HEALTH_SUMMARY AS
SELECT
  COUNT(*)                                                   AS PIPES_TOTAL,
  COUNT_IF(IS_ENABLED)                                       AS PIPES_ENABLED,
  COUNT_IF(UPPER(EXEC_STATE) = 'RUNNING')                    AS RUNNING_CNT,
  COUNT_IF(LAST_ERROR IS NOT NULL AND LAST_ERROR <> '')      AS HAS_ERROR_CNT,
  COUNT_IF(COALESCE(PENDING_FILE_COUNT,0) > 0)               AS HAS_PENDING_FILES_CNT,
  COUNT_IF(COALESCE(OUTSTANDING_MSGS,0) > 0)                 AS HAS_OUTSTANDING_MSGS_CNT
FROM MONITORING.V_PIPE_STATUS_LATEST_ENRICHED;

-- 5.8 Alerts view 
CREATE OR REPLACE VIEW MONITORING.V_PIPE_ALERTS AS
WITH st AS (
  SELECT *
  FROM MONITORING.V_PIPE_STATUS_LATEST_ENRICHED
),
fr AS (
  SELECT *
  FROM MONITORING.V_FRESHNESS
)
SELECT
  st.PIPE_NAME,
  st.TARGET_TABLE,
  st.INTEGRATION,
  st.STAGE_NAME,
  st.EXEC_STATE,
  st.PENDING_FILE_COUNT,
  st.OUTSTANDING_MSGS,
  st.LAST_ERROR,
  fr.LAST_SUCCESS_LOAD_TIME,
  fr.MINUTES_SINCE_SUCCESS,
  CASE
    WHEN st.LAST_ERROR IS NOT NULL AND st.LAST_ERROR <> '' THEN 'ERROR'
    WHEN COALESCE(st.PENDING_FILE_COUNT,0) > 0 THEN 'PENDING_FILES'
    WHEN COALESCE(st.OUTSTANDING_MSGS,0) > 0 THEN 'OUTSTANDING_QUEUE_MSGS'
    WHEN fr.LAST_SUCCESS_LOAD_TIME IS NULL THEN 'NO_SUCCESS_YET'
    WHEN fr.MINUTES_SINCE_SUCCESS > 180 THEN 'STALE_GT_3H'
    ELSE NULL
  END AS ALERT_TYPE
FROM st
LEFT JOIN fr
  ON fr.PIPE_NAME = st.PIPE_NAME
 AND fr.TARGET_TABLE = st.TARGET_TABLE
WHERE
  (st.LAST_ERROR IS NOT NULL AND st.LAST_ERROR <> '')
  OR COALESCE(st.PENDING_FILE_COUNT,0) > 0
  OR COALESCE(st.OUTSTANDING_MSGS,0) > 0
  OR fr.LAST_SUCCESS_LOAD_TIME IS NULL
  OR fr.MINUTES_SINCE_SUCCESS > 180;

-- 5.9 Copy snapshot agg: last 24h by pipe
CREATE OR REPLACE VIEW MONITORING.V_COPY_LAST_24H_BY_PIPE AS
SELECT
  PIPE_NAME,
  TARGET_TABLE,
  COUNT(*)                                       AS FILE_EVENTS,
  COUNT_IF(UPPER(STATUS) LIKE 'LOADED%')         AS LOADED_EVENTS,
  COUNT_IF(UPPER(STATUS) LIKE 'FAILED%')         AS FAILED_EVENTS,
  SUM(COALESCE(ROW_COUNT,0))                     AS ROWS_LOADED,
  SUM(COALESCE(FILE_SIZE,0))                     AS BYTES_LOADED,
  MAX(LAST_LOAD_TIME)                            AS MAX_LAST_LOAD_TIME
FROM MONITORING.COPY_HISTORY_SNAPSHOTS
WHERE LAST_LOAD_TIME >= DATEADD('HOUR', -24, CURRENT_TIMESTAMP())
GROUP BY PIPE_NAME, TARGET_TABLE;

-- === DEBUG NOW (after STEP 5) ===
-- CALL MONITORING.SNAP_COPY_HISTORY(24);
-- SELECT * FROM MONITORING.V_PIPE_HEALTH_SUMMARY;
-- SELECT * FROM MONITORING.V_PIPE_ALERTS ORDER BY ALERT_TYPE, PIPE_NAME;


-- =============================================================================
-- STEP 6) PROC: REFRESH ALL PIPES (manual backfill safety)
-- =============================================================================
CREATE OR REPLACE PROCEDURE MONITORING.REFRESH_ALL_PIPES()
RETURNS STRING
LANGUAGE SQL
EXECUTE AS OWNER
AS
$$
BEGIN
  -- OSM
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_ADMIN REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_ROADS REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_CHARGING REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_POI_POINTS REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_POI_POLYGONS REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_PT_POINTS REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_PT_LINES REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_OSM_BUILDINGS_ACTIVITY REFRESH;

  -- GISCO
  ALTER PIPE GEO_PROJECT.TASKS.P_GISCO_NUTS REFRESH;

  -- EUROSTAT
  ALTER PIPE GEO_PROJECT.TASKS.P_EUROSTAT_LAU_DEGURBA REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_EUROSTAT_CENSUS_GRID_2021_EUROPE REFRESH;
  ALTER PIPE GEO_PROJECT.TASKS.P_EUROSTAT_TRAN_R_ELVEHST REFRESH;

  RETURN 'OK refreshed all pipes';
END;
$$;

-- === DEBUG NOW (after STEP 6) ===
-- CALL MONITORING.REFRESH_ALL_PIPES();


-- =============================================================================
-- STEP 7) ORCHESTRATOR PROC (one call from TASK)
-- =============================================================================
CREATE OR REPLACE PROCEDURE MONITORING.RUN_MONITORING(HOURS_BACK NUMBER)
RETURNS VARIANT
LANGUAGE SQL
EXECUTE AS OWNER
AS
$$
DECLARE
  v1 VARIANT;
  v2 VARIANT;
BEGIN
  v1 := (CALL MONITORING.SNAP_PIPE_STATUS());
  v2 := (CALL MONITORING.SNAP_COPY_HISTORY(:HOURS_BACK));

  RETURN OBJECT_CONSTRUCT(
    'status','OK',
    'pipe_status', v1,
    'copy_history', v2,
    'hours_back', HOURS_BACK
  );
END;
$$;

-- === DEBUG NOW (after STEP 7) ===
-- CALL MONITORING.RUN_MONITORING(24);
-- SELECT COUNT(*) FROM MONITORING.PIPE_STATUS_SNAPSHOTS;
-- SELECT COUNT(*) FROM MONITORING.COPY_HISTORY_SNAPSHOTS;


-- =============================================================================
-- STEP 8) TASKS 
-- =============================================================================

-- 8.1 Monitoring task 
CREATE OR REPLACE TASK MONITORING.T_MONITOR_PIPES
  WAREHOUSE = COMPUTE_WH
  SCHEDULE  = 'USING CRON */10 * * * * UTC'
AS
  CALL MONITORING.RUN_MONITORING(2);

-- 8.2 Refresh safety task  — once per hour
CREATE OR REPLACE TASK MONITORING.T_PIPE_REFRESH_SAFETY
  WAREHOUSE = COMPUTE_WH
  SCHEDULE  = 'USING CRON 0 * * * * UTC'
AS
  CALL MONITORING.REFRESH_ALL_PIPES();

-- Enable when ready:
-- ALTER TASK MONITORING.T_MONITOR_PIPES RESUME;
-- ALTER TASK MONITORING.T_PIPE_REFRESH_SAFETY RESUME;


-- =============================================================================
-- STEP 9) QUICK CHECK PACK 
-- =============================================================================
-- 1) registry
-- SELECT * FROM MONITORING.PIPE_REGISTRY ORDER BY PIPE_NAME;

-- 2) take snapshots now
-- CALL MONITORING.SNAP_PIPE_STATUS();
-- CALL MONITORING.SNAP_COPY_HISTORY(24);

-- 3) inspect
-- SELECT * FROM MONITORING.V_PIPE_STATUS_LATEST_ENRICHED ORDER BY PIPE_NAME;
-- SELECT * FROM MONITORING.V_LAST_SUCCESS_FILE ORDER BY LAST_LOAD_TIME DESC;
-- SELECT * FROM MONITORING.V_PIPE_ALERTS ORDER BY ALERT_TYPE, PIPE_NAME;
-- SELECT * FROM MONITORING.V_PIPE_HEALTH_SUMMARY;
-- SELECT * FROM MONITORING.V_COPY_LAST_24H_BY_PIPE ORDER BY MAX_LAST_LOAD_TIME DESC;